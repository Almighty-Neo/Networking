diff --git a/Simplesniffer/SkyEyePublicHeader.h b/Simplesniffer/SkyEyePublicHeader.h
new file mode 100755
index 0000000..49569f6
--- /dev/null
+++ b/Simplesniffer/SkyEyePublicHeader.h
@@ -0,0 +1,19 @@
+#include <string.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <pcap.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netinet/if_ether.h>
+#include <net/ethernet.h>
+#include <netinet/ether.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+
+/* Database Parameter */
+#define DB_ADDRESS "115.28.4.146"
+#define DB_USERNAME "huang"
+#define DB_PASSWORD "AHUTLAMDA"
+#define DB_NAME "test"
+#define DB_PORT 3578
diff --git a/Simplesniffer/SkyEyeSnifferClient.c b/Simplesniffer/SkyEyeSnifferClient.c
new file mode 100755
index 0000000..6e86298
--- /dev/null
+++ b/Simplesniffer/SkyEyeSnifferClient.c
@@ -0,0 +1,531 @@
+
+#include "SkyEyePublicHeader.h"
+#include "SkyEyeSnifferClient.h"
+#include "SkyEyeSnifferPolicy.h"
+
+/*function implement start*/
+
+extern struct policy_list;
+
+extern struct policy_list * policy_list_head;
+extern struct policy_list * policy_list_tail;
+
+
+
+/*
+ * print data in rows of 16 bytes: offset   hex   ascii
+ *
+ * 00000   47 45 54 20 2f 20 48 54  54 50 2f 31 2e 31 0d 0a   GET / HTTP/1.1..
+ */
+void
+print_hex_ascii_line(const u_char *payload, int len, int offset)
+{
+
+	int i;
+	int gap;
+	const u_char *ch;
+
+	/* offset */
+	printf("%05d   ", offset);
+ 
+	/* hex */
+	ch = payload;
+	for(i = 0; i < len; i++) {
+		printf("%02x ", *ch);
+		ch++;
+		/* print extra space after 8th byte for visual aid */
+		if (i == 7)
+			printf(" ");
+	}
+	/* print space to handle line less than 8 bytes */
+	if (len < 8)
+		printf(" ");
+ 
+	/* fill hex gap with spaces if not full line */
+	if (len < 16) {
+		gap = 16 - len;
+		for (i = 0; i < gap; i++) {
+		printf("   ");
+		}
+	}
+	printf("   ");
+ 
+	/* ascii (if printable) */
+	ch = payload;
+	for(i = 0; i < len; i++) {
+		if (isprint(*ch))
+		printf("%c", *ch);
+		else
+		printf(".");
+		ch++;
+	}
+
+	printf("\n");
+
+	return;
+}
+
+/*
+ * print packet payload data (avoid printing binary data)
+ */
+void
+print_payload(const u_char *payload, int len)
+{
+
+ int len_rem = len;
+ int line_width = 16;   /* number of bytes per line */
+ int line_len;
+ int offset = 0;     /* zero-based offset counter */
+ const u_char *ch = payload;
+
+ if (len <= 0)
+  return;
+    
+ /* data fits on one line */
+ if (len <= line_width) {
+  print_hex_ascii_line(ch, len, offset);
+  return;
+ }
+
+ /* data spans multiple lines */
+ for ( ;; ) {
+  /* compute current line length */
+  line_len = line_width % len_rem;
+  /* print line */
+  print_hex_ascii_line(ch, line_len, offset);
+  /* compute total remaining */
+  len_rem = len_rem - line_len;
+  /* shift pointer to remaining bytes to print */
+  ch = ch + line_len;
+  /* add offset */
+  offset = offset + line_width;
+  /* check if we have line width chars or less */
+  if (len_rem <= line_width) {
+   /* print last line and get out */
+   print_hex_ascii_line(ch, len_rem, offset);
+   break;
+  }
+ }
+
+return;
+}
+
+void process_packet(u_char *arg, const struct pcap_pkthdr *pkthdr, const u_char *packet) {
+	int i = 0, *counter = (int *)arg;
+	const struct db_ip *ip;
+    u_int length = pkthdr->len;
+    u_int hlen, off, version;
+    int len;
+	//int pointer_offset = 0;
+	//u_char *pointer_str;
+
+    /* jump pass the ethernet header */
+    ip = (struct db_ip *)(packet + sizeof(struct ether_header));
+    length -= sizeof(struct ether_header);
+
+    /* check to see we have a packet of valid length */
+    if (length < sizeof(struct db_ip))
+    {
+        printf("truncated ip %d\n", length);
+        return;
+    }
+    len = ntohs(ip->ip_len);
+    hlen = IP_HL(ip); /* header length */
+    version = IP_V(ip);/* ip version */
+    /* check version */
+    if (version != 4 && version != 6)
+    {
+        //fprintf(stdout, "Unknown version %d\n", version);
+        return;
+    }
+    /* check header length */
+    if (hlen < 5 )
+    {
+        //fprintf(stdout, "bad-hlen %d \n", hlen);
+    }
+    /* see if we have as much packet as we should */
+    if (length < len)
+		;
+    //    printf("\ntruncated IP - %d bytes missing\n", len - length);
+    /* Check to see if we have the first fragment */
+    off = ntohs(ip->ip_off);
+
+    /* Print details of packets only from 192.168.42.5*/
+    if (!strcmp(inet_ntoa(ip->ip_src), "192.168.42.8"))
+    {
+
+
+		if(ip->ip_p == 6 || 1) // TCP protocal
+		{
+
+
+			int tcp_offset = sizeof(struct ether_header)
+				+ sizeof(struct db_ip);
+			struct db_tcp * tcp = (struct db_tcp*)(packet + tcp_offset);
+			int tcppacket_offset = tcp_offset + TH_OFF(tcp)*4;
+
+			if(1 && 0 == check_keywords(
+				packet + tcppacket_offset, 
+				pkthdr->len - TH_OFF(tcp)*4)
+				)
+				return;
+
+			// To AHUT student information system
+/*
+			printf("Username:");
+			get_string(packet + tcppacket_offset + pointer_offset + 8, 
+				length - tcppacket_offset - pointer_offset, 
+				'&');
+			pointer_offset = find_string(
+				packet + tcppacket_offset, 
+				"TextBox2", 
+				length - tcppacket_offset,
+				8);
+			printf("	Password:");
+			get_string(packet + tcppacket_offset + pointer_offset + 8, 
+				length - tcppacket_offset - pointer_offset, 
+				'&');
+			printf("\n");
+
+*/			/* print SOURCE and DESTINATION IPs*/
+//			/
+			printf("Source IP: %s:%d ", inet_ntoa(ip->ip_src), ntohs(tcp->th_sport));
+			printf(" Destination IP: %s:%d \n",inet_ntoa(ip->ip_dst), ntohs(tcp->th_dport));
+			printf("Protocal: %d\n", ip->ip_p);
+			printf("Packet Count: %d\n", ++(*counter));
+			printf("Received Packet Size:%d / %d\n", tcppacket_offset, pkthdr->len);
+			printf("Payload:\n");
+			
+			print_payload(packet + tcppacket_offset, pkthdr->len - TH_OFF(tcp)*4);
+			/*
+			for (i = tcppacket_offset; i < pkthdr->len; i++) {
+					if (isprint(packet[i]))
+							printf("%c ", packet[i]);
+					else 
+							printf(". ");
+
+					if ((i % 48 == 0 && i != 0) || i == pkthdr->len-1)
+							printf("\n");
+							
+			}*/
+		}
+
+    }
+        return;
+}
+
+int main() {
+	char keyword_string[1024] = {0};
+	int count = 0;
+	pcap_t *descr = NULL;
+	char errbuf[PCAP_ERRBUF_SIZE], *device = NULL;
+	memset(errbuf, 0, PCAP_ERRBUF_SIZE);
+	strcpy(errbuf, "1\0");
+
+	load_database();
+	//ip_add = inet_addr("192.168.42.5");
+
+	/* Get the name of the first device suitable for capture */
+	sprintf(keyword_string, "954015636|414430547|15905553384");
+	transfer_keyword(keyword_string, strlen(keyword_string) + 1);
+    define_mark();
+
+	device = pcap_lookupdev(errbuf);
+	printf("Find net device: %s\n", device);
+
+
+
+	/* Open device in promiscuous mode */
+	descr = pcap_open_live("wlan0", MAXBYTE2CAPTURE, 1, 512, errbuf);
+	printf("Wlan listening begining.\n");
+	/* Loop forever & call process_packet() for every received packet */
+	pcap_loop(descr, -1, got_ethernet_packet, (u_char *)&count);
+
+	return 0;
+}
+
+int 
+got_data_package(u_char *args,const struct pcap_pkthdr *header,const u_char *packet,int size_header, struct header_info * inf, const struct policy_list * plc)
+{
+	const u_char *payload;                    /* Packet payload */ 
+	int size_payload;
+  
+	/* define/compute  payload (segment) offset */
+	payload = (u_char *)(packet + size_header);
+ 
+	/* compute tcp payload (segment) size */
+	const struct db_ip *ip;
+	ip = (struct db_ip*)(packet + SIZE_ETHERNET);
+	size_payload = ntohs(ip->ip_len) - (size_header-SIZE_ETHERNET);//data len=total len-size_ip-size_tcp
+ 
+	/*
+	* Print payload data; it might be binary, so don't just
+	* treat it as a string.
+	*/
+
+	// Check Key Words
+	int keyword_mark = policy_check_keywords(
+		payload, 
+		size_payload,
+		plc
+		);
+
+	if(1 && 0 == keyword_mark)
+		return 0;
+	//else
+		//strcpy(inf->keyword, get_keyword(keyword_mark - 1));
+
+	if (size_payload > 0 && (1 || find_mark(payload, size_payload) != -1)) {
+		inf->payload = payload;
+		inf->payload_length = size_payload;
+
+		printf("Payload (%d bytes):\n", size_payload);
+		print_payload(payload, size_payload);
+        return 1;
+	}
+	return 0;
+}
+
+int 
+got_udp_package(u_char *args,const struct pcap_pkthdr *header,const u_char *packet,int size_ip, struct header_info * inf, const struct policy_list * plc)
+{
+	struct db_udp *udp;
+	int  size_udp;
+	int  ret = 0;
+	u_short sport;
+	u_short dport;
+	u_short length;
+	udp=(struct db_udp*)(packet+size_ip);
+	sport=ntohs(udp->udp_source_port);
+	dport=ntohs(udp->udp_destination_port);
+	length=ntohs(udp->udp_length);
+
+ 
+	if((plc->sport == 0 || sport == plc->sport) && (plc->dport == 0 || dport == plc->dport))
+		ret = got_data_package(args,header,packet,size_udp,inf,plc);
+
+	if(ret){
+		printf("-------UDP Protocol (Transport Layer)---------\n");
+		printf("Source Port:%d\n",sport);
+		printf("Destination Port:%d\n",dport);
+		printf("Length:%d\n",length);
+		printf("Checksum:%d\n",ntohs(udp->udp_checksum));
+		size_udp = length + size_ip;
+	}
+	return ret;
+}
+
+/*
+ * dissect/print tcp packet
+ */
+int 
+got_tcp_package(u_char *args,const struct pcap_pkthdr *header,const u_char *packet,int size_ip, struct header_info * inf, const struct policy_list * plc)
+{ 
+	const struct db_tcp *tcp;            /* The TCP header */
+	int size_tcp; 
+	int  ret = 0;
+
+	u_char flags;
+	u_short windows;
+	u_short urgent_pointer;
+	u_int sequence;
+	u_int acknowledgement;
+	u_int16_t checksum;
+	u_short sport;
+	u_short dport;
+ 
+	/* define/compute tcp header offset */
+	tcp = (struct db_tcp*)(packet + size_ip);
+	size_tcp = TH_OFF(tcp)*4;
+
+	if (size_tcp < 20) {
+		printf(" * Invalid TCP header length: %u bytes\n", size_tcp);
+		return ret;
+	}
+	sequence=ntohl(tcp->th_seq);
+	acknowledgement=ntohl(tcp->th_ack);
+	windows=ntohs(tcp->th_win);
+	urgent_pointer=ntohs(tcp->th_urp);
+	flags=tcp->th_flags;
+	checksum=ntohs(tcp->th_sum);
+	sport=ntohs(tcp->th_sport);
+	dport=ntohs(tcp->th_dport);
+
+
+	size_tcp=size_tcp+size_ip;
+	/* Set relative information */
+	inf->original_port = sport;
+	inf->destination_port = dport;
+
+	if((plc->sport == 0 || sport == plc->sport) && (plc->dport == 0 || dport == plc->dport))
+		ret = got_data_package(args,header,packet,size_tcp,inf,plc);
+  
+
+	if(ret){
+		printf("-------TCP Protocol (Transport Layer)---------\n");
+		printf("   Src port: %d\n", sport);
+		printf("   Dst port: %d\n", dport);
+		printf("Sequence Number:%u\n Acknowledgement Number:%u\n Header Length:%d\n Reserved:%d\n",sequence,acknowledgement,size_tcp,tcp->th_offx2);
+		printf("Flags:");
+		if(flags & 0x08) printf("PSH");
+		if(flags & 0x10) printf("ACK");
+		if(flags & 0x02) printf("SYN");
+		if(flags & 0x20) printf("URG");
+		if(flags & 0x01) printf("FIN");
+		if(flags & 0x04) printf("RST");
+		printf("\n");
+		printf("Window Size:%d\n",windows);
+		printf("Checksum:%d\n",checksum);
+		printf("Urgent Pointer:%d\n",urgent_pointer);
+	}
+	return ret;
+}
+
+/*
+ * dissect/print ip packet
+ */
+int 
+got_ip_package(u_char *args,const struct pcap_pkthdr *header,const u_char *packet, struct header_info * inf, const struct policy_list * plc)
+{
+	const struct db_ip *ip;              /* The IP header */
+	int size_ip;
+	int  ret = 0;
+
+	u_int offset;
+	u_char tos;
+	u_int16_t checksum;
+       
+	/* define/compute ip header offset */
+	ip = (struct db_ip*)(packet + SIZE_ETHERNET);
+	size_ip = IP_HL(ip)*4;
+	if (size_ip < 20) {
+		printf("*Invalid IP header length: %u bytes\n", size_ip);
+		return ret;
+	}
+	checksum=ntohs(ip->ip_sum);
+	tos=ip->ip_tos;
+	offset=ntohs(ip->ip_off);
+
+	//if (1 && strcmp(inet_ntoa(ip->ip_src), "192.168.42.8"))
+ //   {
+	//	return ret;
+	//}
+
+	/* print source and destination IP addresses */
+	strcpy(inf->original_ip, inet_ntoa(ip->ip_src));
+	strcpy(inf->destination_ip, inet_ntoa(ip->ip_dst));
+	inf->protocal = ip->ip_p;
+
+	/* determine protocol */ 
+	size_ip=size_ip+SIZE_ETHERNET;
+	//printf("IP Header Checking..\n");
+	/* Compare Packet Information to Policy */
+	if(((ip->ip_src.s_addr & plc->ip_source_mask) == (plc->ip_source_mask & plc->ip_source)) &&
+		((ip->ip_dst.s_addr & plc->ip_destination_mask) == (plc->ip_destination_mask & plc->ip_destination)) && 
+		(plc->proto_type == 0 || plc->proto_type == ip->ip_p)
+		)
+	{
+		switch(ip->ip_p) {
+			case IPPROTO_TCP:
+				ret = got_tcp_package(args,header,packet,size_ip,inf,plc);
+				break;
+			case IPPROTO_UDP: 
+				ret = got_udp_package(args,header,packet,size_ip,inf,plc);
+				break;
+			default:
+				printf("   Protocol: unknown\n");
+				break;
+		}
+	}
+
+	if(ret){
+		printf("-------IP Protocol (Network Layer)---------\n");
+		printf("IP Version:%d\n",IP_V(ip));
+		printf("Header Length:%d\n",size_ip);
+		printf("TOS:%d\n",tos);
+		printf("Total length:%d\n",ntohs(ip->ip_len));
+		printf("Identification:%d\n",ntohs(ip->ip_id));
+		printf("Offset:%d\n",(offset & 0x1fff)*8);
+		printf("TTL:%d\n",ip->ip_ttl);
+		printf("Header checksum:%d\n",checksum);
+		printf(" From: %s", inet_ntoa(ip->ip_src));
+		printf("  To: %s\n", inet_ntoa(ip->ip_dst));
+		/* Insert Information to Database*/
+		/*
+		insert_information_test_string(
+			inf->original_ip, 
+			inf->destination_ip, 
+			inf->original_port, 
+			inf->destination_port, 
+			inf->keyword,
+			inf->payload,
+			inf->payload_length);
+			*/
+	}
+
+	return ret;
+}
+
+/*
+ * dissect/print ethernet packet
+ */
+void
+got_ethernet_packet(u_char *args, const struct pcap_pkthdr *header, const u_char *packet)
+{
+	static int count = 1;                   /* packet counter */
+	struct policy_list * pEnum = policy_list_head;	/* policy list */
+	struct header_info inf;				/* The Information */
+
+
+	/* declare pointers to packet headers */
+	const struct db_ethernet *ethernet;  /* The ethernet header [1] */
+		u_short ethernet_type;
+		u_char *mac_string;
+
+	//printf("================The %d package is captured.======================\n",count);
+	count++;
+
+	//	printf("-------Ethernet Protocol (Link Layer)---------\n");
+	/* get ethernet header */    
+	ethernet = (struct db_ethernet*)(packet);
+	/*
+	//printf("Mac Source Address is:\n"); 
+	//mac_string=(u_char*)ethernet->ether_shost;
+	//printf("%02x:%02x:%02x:%02x:%02x:%02x\n",*mac_string,*(mac_string+1),*(mac_string+2),*(mac_string+3),*(mac_string+4),*(mac_string+5));
+	//printf("Mac Destination Address is:\n");
+	//mac_string=(u_char*)ethernet->ether_dhost;
+	//printf("%02x:%02x:%02x:%02x:%02x:%02x\n",*mac_string,*(mac_string+1),*(mac_string+2),*(mac_string+3),*(mac_string+4),*(mac_string+5));
+	ethernet_type=ntohs(ethernet ->ether_type);
+	switch(ethernet_type)
+	{
+		case 0x0800: got_ip_package(args,header,packet);break;
+		//case 0x0806: printf("The network layer is ARP protocol\n");break;
+		//case 0x0835: printf("The network layer is RARP protocol\n");break;
+		default:break;
+	}
+	*/
+
+	memcpy(inf.destination_mac, ethernet->ether_dhost, 6);		//set mac address
+	memcpy(inf.original_mac, ethernet->ether_shost, 6);
+	int check_sign = 0;	//if 0 dont go to next step
+	while(pEnum != 0)
+	{
+		check_sign = 1;
+		if(pEnum->ether_check_shost != 0)
+			if(memcmp(ethernet->ether_shost, pEnum->ether_shost, 6))	//if dont same
+				check_sign = 0;
+		if(pEnum->ether_check_dhost != 0)
+			if(memcmp(ethernet->ether_dhost, pEnum->ether_dhost, 6))	//if dont same
+				check_sign = 0;
+		ethernet_type=ntohs(ethernet ->ether_type);
+		if(ethernet_type != pEnum->ether_type)
+			check_sign = 0;
+		if(check_sign != 0)
+			got_ip_package(args,header,packet,&inf,pEnum);
+
+		pEnum = pEnum->pNext;
+	}
+return;
+}
+
+
diff --git a/Simplesniffer/SkyEyeSnifferClient.h b/Simplesniffer/SkyEyeSnifferClient.h
new file mode 100755
index 0000000..9b32956
--- /dev/null
+++ b/Simplesniffer/SkyEyeSnifferClient.h
@@ -0,0 +1,168 @@
+#include "SkyEyePublicHeader.h"
+#include "SkyEyeSnifferPolicy.h"
+
+#define MAXBYTE2CAPTURE 4096
+
+
+/*protocol define start*/
+/* default snap length (maximum bytes per packet to capture) */
+#define SNAP_LEN 1518
+
+/* ethernet headers are always exactly 14 bytes [1] */
+#define SIZE_ETHERNET 14
+
+/* Ethernet addresses are 6 bytes */
+//#define ETHER_ADDR_LEN 6
+
+/* Ethernet header */
+struct db_ethernet {
+        u_char  ether_dhost[ETHER_ADDR_LEN];    /* destination host address */
+        u_char  ether_shost[ETHER_ADDR_LEN];    /* source host address */
+        u_short ether_type;                     /* IP? ARP? RARP? etc */
+};
+
+/* IP header */
+struct db_ip {
+        u_char  ip_vhl;                 /* version << 4 | header length >> 2 */
+        u_char  ip_tos;                 /* type of service */
+        u_short ip_len;                 /* total length */
+        u_short ip_id;                  /* identification */
+        u_short ip_off;                 /* fragment offset field */
+        #define IP_RF 0x8000            /* reserved fragment flag */
+        #define IP_DF 0x4000            /* dont fragment flag */
+        #define IP_MF 0x2000            /* more fragments flag */
+        #define IP_OFFMASK 0x1fff       /* mask for fragmenting bits */
+        u_char  ip_ttl;                 /* time to live */
+        u_char  ip_p;                   /* protocol */
+        u_short ip_sum;                 /* checksum */
+        struct  in_addr ip_src,ip_dst;  /* source and dest address */
+};
+#define IP_HL(ip)               (((ip)->ip_vhl) & 0x0f)
+#define IP_V(ip)                (((ip)->ip_vhl) >> 4)
+
+/* TCP header */
+typedef u_int tcp_seq;
+
+struct db_tcp {
+        u_short th_sport;               /* source port */
+        u_short th_dport;               /* destination port */
+        tcp_seq th_seq;                 /* sequence number */
+        tcp_seq th_ack;                 /* acknowledgement number */
+        u_char  th_offx2;               /* data offset, rsvd */
+#define TH_OFF(th)      (((th)->th_offx2 & 0xf0) >> 4)
+        u_char  th_flags;
+        #define TH_FIN  0x01
+        #define TH_SYN  0x02
+        #define TH_RST  0x04
+        #define TH_PUSH 0x08
+        #define TH_ACK  0x10
+        #define TH_URG  0x20
+        #define TH_ECE  0x40
+        #define TH_CWR  0x80
+        #define TH_FLAGS        (TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)
+        u_short th_win;                 /* window */
+        u_short th_sum;                 /* checksum */
+        u_short th_urp;                 /* urgent pointer */
+};
+
+/* UDP header */
+struct db_udp//udp protocol
+{
+ u_int16_t udp_source_port;
+ u_int16_t udp_destination_port;
+ u_int16_t udp_length;
+ u_int16_t udp_checksum;
+};
+
+/*
+IP Header
+*/
+
+struct tcphdr
+{
+    u_int16_t source;
+    u_int16_t dest;
+    u_int32_t seq;
+    u_int32_t ack_seq;
+	# if __BYTE_ORDER == __LITTLE_ENDIAN
+    u_int16_t res1:4;
+    u_int16_t doff:4;
+    u_int16_t fin:1;
+    u_int16_t syn:1;
+    u_int16_t rst:1;
+    u_int16_t psh:1;
+    u_int16_t ack:1;
+    u_int16_t urg:1;
+    u_int16_t res2:2;
+# elif __BYTE_ORDER == __BIG_ENDIAN
+    u_int16_t doff:4;
+    u_int16_t res1:4;
+    u_int16_t res2:2;
+    u_int16_t urg:1;
+    u_int16_t ack:1;
+    u_int16_t psh:1;
+    u_int16_t rst:1;
+    u_int16_t syn:1;
+    u_int16_t fin:1;
+# else
+#   error "Adjust your <bits/endian.h> defines"
+# endif
+    u_int16_t window;
+    u_int16_t check;
+    u_int16_t urg_ptr;
+};
+
+struct header_info
+{
+	char destination_mac[6];
+	char original_mac[6];
+	char keyword[48];
+	char original_ip[20];
+	char destination_ip[20];
+	long original_port;
+	long destination_port;
+	char * payload;
+	long payload_length;
+	int protocal;
+};
+
+
+/* function define start */
+
+void
+got_ethernet_packet(u_char *args, const struct pcap_pkthdr *header, const u_char *packet);
+
+int 
+got_ip_package(u_char *args,const struct pcap_pkthdr *header,const u_char *packet, struct header_info * inf, const struct policy_list * plc);
+
+int 
+got_tcp_package(u_char *args,const struct pcap_pkthdr *header,const u_char *packet,int size_ip, struct header_info * inf, const struct policy_list * plc);
+
+int 
+got_udp_package(u_char *args,const struct pcap_pkthdr *header,const u_char *packet,int size_ip, struct header_info * inf, const struct policy_list * plc);
+
+void
+print_payload(const u_char *payload, int len);
+
+void
+print_hex_ascii_line(const u_char *payload, int len, int offset);
+
+int 
+got_data_package(u_char *args,const struct pcap_pkthdr *header,const u_char *packet,int size_header, struct header_info * inf, const struct policy_list * plc);
+
+extern int load_database();
+
+extern int insert_information_test(char * orgIP, char * desIP, int orgPort, int desPort,  char * package, int length);
+
+extern int insert_information_test_string(char * orgIP, char * desIP, int orgPort, int desPort, char * keyword, char * package, int length);
+
+extern int transfer_keyword(const u_char * strKeyword, int lenth);
+
+extern int check_keywords(const u_char * strPackage, int length);
+
+extern int find_mark(const u_char *payload, int len);
+
+extern void define_mark();
+
+extern char * get_keyword(int number);
+/*function define end*/
diff --git a/Simplesniffer/SkyEyeSnifferDatabase.c b/Simplesniffer/SkyEyeSnifferDatabase.c
new file mode 100755
index 0000000..a038df7
--- /dev/null
+++ b/Simplesniffer/SkyEyeSnifferDatabase.c
@@ -0,0 +1,126 @@
+#include <mysql/mysql.h>
+#include "SkyEyePublicHeader.h"
+
+MYSQL DbObj;  //handle
+int connect_stat = 0;
+int load_database()
+{
+	MYSQL_RES *pRes; //result
+	MYSQL_ROW  sqlrow; //row
+	char strsql[200];
+	char username[20];
+	char password[20];
+
+	sprintf(username,DB_USERNAME);
+	sprintf(password,DB_PASSWORD);
+	
+	if(connect_stat)	//if connect already exist, clear memory
+	{
+		unload_database();
+	}
+
+	mysql_init(&DbObj);
+	printf("Connecting....\n");
+
+	if(!mysql_real_connect(&DbObj, DB_ADDRESS, username, password, DB_NAME, DB_PORT, NULL, CLIENT_SSL) )
+	{
+		printf("Error %u: %s\n", mysql_errno(&DbObj), mysql_error(&DbObj));
+		return 0;
+	}
+	char value = 1;
+	mysql_options(&DbObj, MYSQL_OPT_RECONNECT, &value);	//Set this connection reconnectable
+
+
+	printf("Connect Database Successfully!:)\n");
+	connect_stat = 1;
+
+	return 0;
+}
+
+int unload_database()
+{
+		mysql_close(&DbObj);
+}
+
+int insert_information_test(char * orgIP, char * desIP, int orgPort, int desPort, char * package, int length)
+{
+	char insert_string[2048] = {0};
+	char * end;
+	sprintf(insert_string, "insert into skyeye_sensitive_info (sOriIp, sDesIp, iOriPort, iDesPort, varPackage) values (\"%s\", \"%s\", %d, %d, ",
+		orgIP, desIP, orgPort, desPort
+		);
+	printf("%s\n", insert_string);
+
+	if(length > 1500) length = 1500;
+
+	end = insert_string + strlen(insert_string);
+    *end++ = '\'';
+    end += mysql_real_escape_string(&DbObj, end,(char *)package, length * sizeof(char));
+    *end++ = '\'';
+    *end++ = ')';
+
+	mysql_ping(&DbObj);	//Test connection state and if lost we do reconnect
+	if(mysql_real_query(&DbObj, insert_string, (unsigned int)(end - insert_string)))
+	{
+		printf("Error %u: %s\n", mysql_errno(&DbObj), mysql_error(&DbObj));
+
+		switch(mysql_errno(&DbObj))
+		{
+		case 2006:			//Mysql server has gone away
+			load_database();
+		}
+	}
+	return 0;
+}
+
+int insert_information_test_string(char * orgIP, char * desIP, int orgPort, int desPort, char * keyword, char * package, int length)
+{
+	char insert_string[2048] = {0};
+	char * end;
+	if(!check_string(package, length))
+		return 0;
+	sprintf(insert_string, "insert into skyeye_sensitive_info (sOriIp, sDesIp, iOriPort, iDesPort, sKeyword, varPackage) values (\"%s\", \"%s\", %d, %d, \"%s\", \"",
+		orgIP, desIP, orgPort, desPort, keyword
+		);
+
+	memcpy(insert_string + strlen(insert_string), package, length>1500?1500:length);
+	strcat(insert_string + strlen(insert_string), "\")");
+	//printf("%s\n", insert_string);
+
+	mysql_ping(&DbObj);	//Test connection state and if lost we do reconnect
+	if(mysql_real_query(&DbObj, insert_string, strlen(insert_string)))
+	{
+		printf("Error %u: %s\n", mysql_errno(&DbObj), mysql_error(&DbObj));
+
+		switch(mysql_errno(&DbObj))
+		{
+		case 2006:			//Mysql server has gone away
+			load_database();
+		}
+	}
+	return 0;
+}
+
+int check_string(char * packet, int length)
+{
+	int i = 0;
+	for(i = 0; i < length; i++)
+	{
+		if(!(
+			(*(packet + i) >= 32 && *(packet + i) <= 127) || (*(packet + i) > 6 && *(packet + i) < 14)
+			))
+		{
+			break;
+		}
+	}
+	if( i != length )
+	{
+		printf("string check failed. %d\n", i);
+		return 0;
+	}
+	else
+	{
+		printf("string check pass. %d\n", i);
+		return 1;
+	}
+}
\ No newline at end of file
diff --git a/Simplesniffer/SkyEyeSnifferDatabase.h b/Simplesniffer/SkyEyeSnifferDatabase.h
new file mode 100755
index 0000000..771e1ec
--- /dev/null
+++ b/Simplesniffer/SkyEyeSnifferDatabase.h
@@ -0,0 +1,11 @@
+#include "SkyEyePublicHeader.h"
+/*function define start*/
+
+int load_database();
+
+int insert_information_test(char * orgIP, char * desIP, int orgPort, int desPort,  char * package, int length);
+
+int insert_information_test_string(char * orgIP, char * desIP, int orgPort, int desPort, char * keyword, char * package, int length);
+
+int check_string(char * packet, int length);
+/*function define end*/
diff --git a/Simplesniffer/SkyEyeSnifferPolicy.c b/Simplesniffer/SkyEyeSnifferPolicy.c
new file mode 100755
index 0000000..bd0dd19
--- /dev/null
+++ b/Simplesniffer/SkyEyeSnifferPolicy.c
@@ -0,0 +1,414 @@
+#include "SkyEyePublicHeader.h"
+#include "SkyEyeSnifferPolicy.h"
+
+unsigned long ip_add = 0;
+extern struct policy_list;
+
+u_char targetip[16] = {0};			//target ip adress, which you want to listen
+u_char keywords[MAXKEYWORDS][32] = {{0}};//keyword array which turned from keyword string
+u_int  keywordslen[MAXKEYWORDS] = {0};
+u_char keyword[256] = {0};			//origin keyword string, split keyword by mark '|'
+
+u_int  mark_position[MARK_COUNT][MARK_ARRAY_COUNT] = {{0}};   //mark postion array
+u_int  mark_array_count [MARK_COUNT] = {0};
+u_char mark_array[MARK_COUNT][MARK_ARRAY_COUNT] = {{0}};      //mark array
+
+int countKeyword = 0;				//count of keywords
+int mark_count = 0;
+
+
+struct policy_list * policy_list_head = 0;
+struct policy_list * policy_list_tail = 0;
+
+
+/*
+ * set marks and detail inforamtion
+ */
+void define_mark()
+{
+    mark_position[0][0] = 4; mark_array[0][0] = 0x00;
+    mark_position[0][1] = 5; mark_array[0][1] = 0x10;
+    mark_position[0][2] = 6; mark_array[0][2] = 0x00;
+    mark_position[0][3] = 7; mark_array[0][3] = 0x01;
+    mark_array_count[0] = 4;
+    
+    mark_count = 1;
+
+	policy_test();
+}
+
+/*
+ * judge whether or not marks in payload
+ * if yes return >=0
+ * if no return -1
+ */
+int find_mark(const u_char *payload, int len)
+{
+    int i = 0;
+    int n = 0;
+    for(i = 0; i < mark_count; i++)
+    {
+        for (n = 0; n < mark_array_count[i]; n++){
+            if(mark_position[i][n] >= len ||
+               *(payload + mark_position[i][n]) != mark_array[i][n])
+                break;
+        }
+                if(n == mark_array_count[i])
+            return i;
+    }
+
+    return -1;
+}
+
+int last(const u_char *p, u_char c) { //找到c在p中最后匹配的位置,没有就返回－1
+    int length = strlen((char *)p), count  = 0;
+    u_char *pp = (u_char *)p + length -1;
+    while (pp >= p)
+    {
+        if (*pp == c)
+        {
+            return length - count - 1;
+        }
+        pp--;
+        count++;
+    }
+    return -1;
+}
+
+int min(int a, int b){
+    return (a <= b) ? a : b;
+}
+
+int find_string(const u_char *T,const u_char *p, int lenT, int lenP) {
+    int n = lenT;
+    int m = lenP; //strlen(p);
+    int i = m-1, j = m-1;
+    while (i <= n-1)
+    {
+        if (T[i]==p[j])
+        {
+            if (j==0)
+            {
+                return i;
+            }
+            else
+                i--, j--;
+        }
+        else {
+            i = i + m - min(j, 1+last(p, T[i]) ); //往后跳，取决于最后一次匹配的字符的位置
+            j = m - 1;
+        }
+    }
+    return -1;
+}
+
+/*
+ * transfer string to keywords
+ * always return 0
+ */
+int transfer_keyword(const u_char * strKeyword, int lenth)
+{
+	int n = 0;
+	int k = 0;
+	int i = 0;
+	for(i = 0; i < lenth; i++)
+	{
+		if(*(strKeyword + i) != '|' && *(strKeyword + i) != 0)
+			keywords[n][k++] = *(strKeyword + i);
+		else
+		{
+			keywords[n][k++] = '\0';
+			keywordslen[n] = k - 1;
+			k = 0;
+			n++;
+			if(n > MAXKEYWORDS)
+				return -2;			//out of count
+		}
+	}
+	countKeyword = n;
+	//printf("Count: %d\n", n);
+	//for(i = 0; i < n; i++)
+	//{
+	//	printf("%s\n", keywords[i]);
+	//}
+	return 0;
+}
+
+/*
+ * check keywords in string
+ * if yes return a number which is number of keywords + 1
+ * else return 0
+ */
+int check_keywords(const u_char * strPackage, int length)
+{
+	int i = 0;
+	int pointer_offset = 0;
+	for(i = 0; i < countKeyword; i++)
+	{
+		if(-1 == (pointer_offset = find_string(
+			strPackage, 
+			keywords[i], 
+			length,
+			keywordslen[i])))
+			continue;
+		else
+		{
+			printf("Detect Keyword: %s\n", keywords[i]);
+			return 1 + i;
+		}
+		
+	}
+	return 0;
+}
+
+int get_string(u_char * targt, int len, u_char end_sg)
+{
+	int i = 0;
+	for(i = 0; i < len && *(targt + i) != end_sg; i++)
+	{
+		printf("%c", *(targt + i));
+	}
+	return 0;
+}
+
+char * get_keyword(int number)
+{
+	return keywords[number];
+}
+
+/* ---------- Policy Management  ----------- */
+int policy_test()
+{
+	char mac_address[20] = {"00:00:00:00:00:00"};
+	//char * mac_string = mac_address;
+	//printf("%02x:%02x:%02x:%02x:%02x:%02x\n",*mac_string,*(mac_string+1),*(mac_string+2),*(mac_string+3),*(mac_string+4),*(mac_string+5));
+
+	policy_add(
+		mac_address, 
+		"00:00:00:00:00:00", 
+		"115.28.4.146", 
+		"128.0.0.1", 
+		"0.0.0.0", 
+		"0.0.0.0",
+		0x0800,
+		IPPROTO_TCP,
+		21,
+		0,
+		"",
+		"mark"
+		);
+		policy_add(
+		mac_address, 
+		"00:00:00:00:00:00", 
+		"115.28.4.146", 
+		"128.0.0.1", 
+		"0.0.0.0", 
+		"0.0.0.0",
+		0x0800,
+		IPPROTO_TCP,
+		0,
+		21,
+		"",
+		"mark"
+		);
+	return 0;
+}
+
+struct policy_list * policy_add(char * mac_source,
+			   char * mac_destination,
+			   char * ip_source, 
+			   char * ip_destination, 
+			   char * ip_source_mask,
+			   char * ip_destination_mask,
+			   int ethern_protocal,
+			   int protocal,
+			   long port_source,
+			   long port_destination,
+			   char * keyword_string,
+			   char * mark_string)
+{
+	char mac_address[7] = {0};
+	struct policy_list * plc =(struct policy_list *) malloc(sizeof (struct policy_list));
+	struct policy_list * pEnum = policy_list_head;
+	int i = 0;
+	if(plc == 0)
+	{
+		printf("Memory Allocate Error, Add Policy Failed.\n");
+		return 0;
+	}
+
+	memset(plc, 0, sizeof (struct policy_list));
+
+	sscanf(mac_destination, "%02x:%02x:%02x:%02x:%02x:%02x", 
+		&mac_address[0],
+		&mac_address[1],
+		&mac_address[2],
+		&mac_address[3],
+		&mac_address[4],
+		&mac_address[5]
+	);
+	memcpy(plc->ether_dhost, mac_address, 6);
+	plc->ether_check_dhost = 0;
+	for(i = 0; i < 6; i++)
+		plc->ether_check_dhost += *(mac_address + i);
+
+	sscanf(mac_source, "%02x:%02x:%02x:%02x:%02x:%02x", 
+		&mac_address[0],
+		&mac_address[1],
+		&mac_address[2],
+		&mac_address[3],
+		&mac_address[4],
+		&mac_address[5]
+	);
+	memcpy(plc->ether_shost, mac_address, 6);
+	plc->ether_check_shost = 0;
+	for(i = 0; i < 6; i++)
+		plc->ether_check_shost += *(mac_address + i);
+
+
+	plc->ether_type		= ethern_protocal;
+
+	plc->ip_source		= inet_addr(ip_source);
+	plc->ip_destination	= inet_addr(ip_destination);
+
+	plc->ip_source_mask		= inet_addr(ip_source_mask);
+	plc->ip_destination_mask= inet_addr(ip_destination_mask);
+
+	plc->proto_type		= protocal;
+	plc->sport			= port_source;
+	plc->dport			= port_destination;
+
+	plc->pNext			= 0;
+
+	/* ---- Keywords and Marks Add ---- */
+
+	policy_transfer_keyword(keyword_string, strlen(keyword_string) + 1, plc);
+	/* ---- Keywords and Marks End ---- */
+	if(policy_list_head == 0)
+	{
+		policy_list_head = plc;
+	}
+	else
+	{
+		pEnum = policy_list_head;
+		while(pEnum->pNext != 0)
+			pEnum = pEnum->pNext;
+		pEnum->pNext = plc;
+	}
+	printf("Item add!\n");
+
+	return plc;
+}
+
+int policy_del(struct policy_list * des)
+{
+	struct policy_list * pEnum = policy_list_head;
+	struct policy_list * pBuf;
+	if(policy_list_head == 0)
+	{
+		// null list
+		return 0;
+	}
+	else
+	{
+		pEnum = policy_list_head;
+		pBuf = pEnum;
+
+		while(pEnum != 0)
+		{
+			if(pEnum == des)
+			{
+				if(pBuf == policy_list_head)
+					policy_list_head = des->pNext;
+				else
+					pBuf->pNext = des->pNext;
+
+				free(des);		// Release Memory
+				printf("Item delete!\n");
+				break;
+			}
+			pBuf = pEnum;
+			pEnum = pEnum->pNext;
+		}
+		
+	}
+	return 1;
+}
+
+int policy_clear()
+{
+	if(policy_list_head == 0)
+	{
+		// null list
+		return 0;
+	}
+	while(policy_list_head != 0)
+		policy_del(policy_list_head);
+	
+	return 1;
+}
+
+int policy_transfer_keyword(const u_char * strKeyword, int lenth, struct policy_list * plc)
+{
+	int n = 0;
+	int k = 0;
+	int i = 0;
+	if(strlen(strKeyword) == 0)
+	{
+		plc->keywords_count = 0;
+		return 0;
+	}
+	for(i = 0; i < lenth; i++)
+	{
+		if(*(strKeyword + i) != '|' && *(strKeyword + i) != 0)
+			plc->keywords[n][k++] = *(strKeyword + i);
+		else
+		{
+			plc->keywords[n][k++] = '\0';
+			plc->keywordslen[n] = k - 1;
+			k = 0;
+			n++;
+			if(n > MAXKEYWORDS)
+				return -2;			//out of count
+		}
+	}
+	plc->keywords_count = n;
+	printf("Count: %d\n", n);
+	//for(i = 0; i < n; i++)
+	//{
+	//	printf("%s\n", keywords[i]);
+	//}
+	return 0;
+}
+
+int policy_transfer_fingerprint(const u_char * strKeyword, struct policy_list * plc)
+{
+
+}
+
+int policy_check_keywords(const u_char * strPackage, int length, struct policy_list * plc)
+{
+	int i = 0;
+	int pointer_offset = 0;
+	if(plc->keywords_count == 0)
+		return 1;
+	printf("Check Keywords\n");
+	for(i = 0; i < plc->keywords_count; i++)
+	{
+		if(-1 == (pointer_offset = find_string(
+			strPackage, 
+			plc->keywords[i], 
+			length,
+			plc->keywordslen[i])))
+			continue;
+		else
+		{
+			printf("Detect Keyword: %s\n", plc->keywords[i]);
+			return 1 + i;
+		}
+		
+	}
+	return 0;
+}
+
+/* ----------------------------------------- */
\ No newline at end of file
diff --git a/Simplesniffer/SkyEyeSnifferPolicy.h b/Simplesniffer/SkyEyeSnifferPolicy.h
new file mode 100755
index 0000000..7ccba74
--- /dev/null
+++ b/Simplesniffer/SkyEyeSnifferPolicy.h
@@ -0,0 +1,74 @@
+#include "SkyEyePublicHeader.h"
+#ifndef COMDEF_H_POLICY
+#define COMDEF_H_POLICY
+
+#define MAXKEYWORDS 10
+
+// marks define
+#define MARK_ARRAY_COUNT 10
+#define MARK_COUNT 20
+
+struct policy_list{
+	u_int ether_check_dhost;	//Check or not destination Mac Address
+	u_int ether_check_shost;	//Check or not source Mac Address
+	char ether_dhost[6];		//Destination Mac Address 
+	char ether_shost[6];		//Source Mac Address
+	u_short ether_type;			//Ethern Type: ARP, RARP, IP
+
+	u_long ip_source;			//Source IP Address
+	u_long ip_destination;		//Destination IP Address
+	u_long ip_source_mask;
+	u_long ip_destination_mask;
+
+	u_short proto_type;			//Protocal Type: UDP, TCP
+	u_short sport;				//Source Port
+	u_short dport;				//Destination Port
+
+	u_char keywords[MAXKEYWORDS][32];//keyword array which turned from keyword string
+	u_int  keywordslen[MAXKEYWORDS];
+	u_char keyword[256];			//origin keyword string, split keyword by mark '|'
+
+	u_int  mark_position[MARK_COUNT][MARK_ARRAY_COUNT];   //mark postion array
+	u_int  mark_array_count [MARK_COUNT];
+	u_char mark_array[MARK_COUNT][MARK_ARRAY_COUNT];      //mark array
+
+	int keywords_count;
+	int marks_count;
+
+	struct policy_list * pNext;
+};
+
+
+
+int transfer_keyword(const u_char * strKeyword, int lenth);
+
+int check_keywords(const u_char * strPackage, int length);
+
+int find_mark(const u_char *payload, int len);
+
+void define_mark();
+
+char * get_keyword(int number);
+
+int policy_test();
+
+
+struct policy_list * policy_add(char * mac_source,
+			   char * mac_destination,
+			   char * ip_source, 
+			   char * ip_destination, 
+			   char * ip_source_mask,
+			   char * ip_destination_mask,
+			   int ethern_protocal,
+			   int protocal,
+			   long port_source,
+			   long port_destination,
+			   char * keyword_string,
+			   char * mark_string);
+
+int policy_del(struct policy_list * des);
+
+int policy_clear();
+
+
+#endif
\ No newline at end of file
diff --git a/Simplesniffer/makefile b/Simplesniffer/makefile
new file mode 100755
index 0000000..67a4012
--- /dev/null
+++ b/Simplesniffer/makefile
@@ -0,0 +1,19 @@
+OBJS = SkyEyeSnifferClient.o SkyEyeSnifferDatabase.o SkyEyeSnifferPolicy.o
+CC = gcc
+CFLAGES  = -Wall -lpcap -lmysqlclient -g
+RM = rm -f
+
+executable: $(OBJS)
+	$(CC) $(OBJS) -o SkyEyeSnifferClient -lpcap -lmysqlclient
+
+SkyEyeSnifferClient.o : SkyEyeSnifferClient.c SkyEyePublicHeader.h SkyEyeSnifferClient.h  /usr/local/include/pcap/pcap.h
+	$(CC) -c $< -o $@
+
+SkyEyeSnifferDatabase.o : SkyEyeSnifferDatabase.c SkyEyePublicHeader.h SkyEyeSnifferDatabase.h /usr/include/mysql/mysql.h 
+	$(CC) -c $< -o $@
+
+SkyEyeSnifferPolicy.o : SkyEyeSnifferPolicy.c SkyEyePublicHeader.h SkyEyeSnifferPolicy.h 
+	$(CC) -c $< -o $@
+
+clean :
+	$(RM) *.o
\ No newline at end of file
